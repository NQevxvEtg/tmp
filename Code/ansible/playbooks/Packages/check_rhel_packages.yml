- name: Check RHEL package versions
  ignore_unreachable: yes
  hosts: reachable
  become: true
  
  vars_files:
    # Ensure this path is correct relative to your playbook location
    - ../../vaults/vbox_vault.yml 
    
  vars:
    ansible_become_password: "{{ remote_host_become_pass }}"
    ansible_remote_tmp: /var/ansible_tmp
    
    # Pass the entire file content formatted as a newline-separated string (each line: name-version-release)
    required_packages_raw_data: "{{ lookup('file', playbook_dir + '/../../files/package_versions.txt').splitlines() | map('trim') | reject('equalto', '') | join('\n') }}"
    output_file: "{{ playbook_dir }}/../../files/rhel_vulnerability_report.txt"


  tasks:
    - name: Install rpmdevtools for version comparison
      become: true
      ansible.builtin.package:
        name: rpmdevtools
        state: present
      when: ansible_os_family == "RedHat"


    - name: Get primary group for local file permissions
      delegate_to: localhost
      ansible.builtin.shell: 
        cmd: id -gn "{{ lookup('env', 'USER') }}"
      register: primary_group
      changed_when: false

      
    - name: Execute single-pass, optimized version check
      ansible.builtin.shell: |
        #!/bin/bash
        
        # Guard against older bash versions (RHEL 7 might need this)
        # Check if the shell supports BASH_REMATCH (usually yes on RHEL 8+)
        if ! command -v bash >/dev/null 2>&1 || [[ "${BASH_VERSION%%[^0-9]*}" -lt 3 ]]; then
            echo "Error: Bash version too old or not installed." >&2
            exit 1
        fi

        # Injected newline-separated string of requirements (each line: name-version-release)
        REQUIRED_RAW_DATA="{{ required_packages_raw_data }}"
        
        REPORT_DATA=""
        HOST_NAME="{{ inventory_hostname }}"
        
        # Function to compare RPM versions using rpmdev-vercmp
        # Returns: 0 if equal, 11 if ver1 > ver2, 12 if ver1 < ver2
        compare_rpm_versions() {
            local ver1="$1"
            local ver2="$2"
            
            # Use rpmdev-vercmp to properly compare versions
            if command -v rpmdev-vercmp >/dev/null 2>&1; then
                # Success (0=equal), Failure (11=ver1>ver2, 12=ver1<ver2)
                rpmdev-vercmp "$ver1" "$ver2" >/dev/null 2>&1
                return $?
            else
                # Fallback method using sort -V (less reliable for true RPM versioning)
                local lowest=$(echo -e "$ver1\n$ver2" | sort -V | head -n 1)
                if [[ "$lowest" == "$ver1" ]] && [[ "$ver1" != "$ver2" ]]; then
                    return 12  # ver1 < ver2
                elif [[ "$lowest" == "$ver2" ]] && [[ "$ver1" != "$ver2" ]]; then
                    return 11  # ver1 > ver2
                else
                    return 0   # ver1 == ver2
                fi
            fi
        }
        
        # Read the raw data line by line
        while IFS= read -r RAW_ENTRY; do
            if [[ -z "$RAW_ENTRY" ]]; then continue; fi
    
            PKG_NAME_LOOKUP=""
            REQUIRED_VR=""
            
            # Use BASH regex matching to robustly split NAME from VERSION-RELEASE.
            # Look for the last hyphen NOT followed by a digit as part of the name, 
            # and the first hyphen followed by a digit as the split point.
            if [[ "$RAW_ENTRY" =~ ^(.*)-([0-9].*)$ ]]; then
                PKG_NAME_LOOKUP="${BASH_REMATCH[1]}" # Package Name (e.g., openssh-clients)
                REQUIRED_VR="${BASH_REMATCH[2]}"    # Version-Release (e.g., 8.0p1-26.el8_10)
            else
                echo "Warning: Entry failed regex parsing: $RAW_ENTRY" >&2
                continue
            fi
            
            # Sanity check
            if [[ -z "$PKG_NAME_LOOKUP" ]] || [[ -z "$REQUIRED_VR" ]]; then
                echo "Critical Error: Failed to assign values for entry: $RAW_ENTRY" >&2
                continue
            fi
            
            # Query installed packages with Version-Release only 
            # Note: We must quote $PKG_NAME_LOOKUP because it might contain hyphens
            INSTALLED_VRS=$(rpm -qa "$PKG_NAME_LOOKUP" --queryformat '%{VERSION}-%{RELEASE}\n' 2>/dev/null)
            
            if [[ -z "$INSTALLED_VRS" ]]; then
                # Package not installed - skip silently 
                continue
            fi
    
            # Check each installed version (there might be multiple architectures/versions installed)
            while IFS= read -r installed_vr; do
                if [[ -z "$installed_vr" ]]; then continue; fi
                
                # Compare installed version with required version
                compare_rpm_versions "$installed_vr" "$REQUIRED_VR"
                RESULT=$?
                
                # If installed < required (exit code 12), report it
                if [[ $RESULT -eq 12 ]]; then
                    # Package is deficient
                    REPORT_DATA+="$HOST_NAME|$PKG_NAME_LOOKUP|$installed_vr|$REQUIRED_VR\n"
                    break  # Only report the deficiency once per package name
                fi
            done <<< "$INSTALLED_VRS"
            
        done <<< "$REQUIRED_RAW_DATA"
        
        # Output the report data
        echo -e "$REPORT_DATA"
      register: package_check_results
      changed_when: false


    - name: Generate and write a single combined report
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        content: |
          # Package Version Deficiencies Report
          # Generated by Ansible at: {{ ansible_date_time.iso8601 | regex_replace('\\..*$', '') }}
          # -------------------------------------------------------------
          # HOSTNAME,PACKAGE_NAME,INSTALLED_VERSION,REQUIRED_MINIMUM_VERSION

          {% for host in ansible_play_hosts %}
          {% set raw_stdout = hostvars[host].package_check_results.stdout | default('') %}
          {% set raw_lines = raw_stdout.split('\n') | map('trim') | reject('equalto', '') | list %}
          
          {% for line in raw_lines %}
          {% set parts = line.split('|') %}
          {% if parts | length == 4 %}
          {{ parts[0] | upper }},{{ parts[1] }},{{ parts[2] }},{{ parts[3] }}
          {% endif %}
          {% endfor %}
          {% endfor %}
        dest: "{{ output_file }}"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ primary_group.stdout | default(omit) }}"
        mode: '0644'