---
- name: Check RHEL package versions
  ignore_unreachable: yes
  hosts: reachable
  become: true
  
  vars_files:
    - ../../vaults/vbox_vault.yml 
  vars:
    ansible_become_password: "{{ remote_host_become_pass }}"
    ansible_remote_tmp: /var/ansible_tmp
    
    # Pass the entire file content formatted as a newline-separated string (each line: name:version)
    # We use join('\n') to ensure it is a single, clean string variable
    required_packages_raw_data: "{{ lookup('file', playbook_dir + '/../../files/package_versions.txt').splitlines() | map('trim') | reject('equalto', '') | join('\n') }}"
    output_file: "{{ playbook_dir }}/../../files/rhel_vulnerability_report.txt"

  tasks:
    - name: Get primary group for local file permissions
      delegate_to: localhost
      ansible.builtin.shell: 
        cmd: id -gn "{{ lookup('env', 'USER') }}"
      register: primary_group
      changed_when: false

    - name: Execute single-pass, optimized version check
      ansible.builtin.shell: |
        #!/bin/bash
        
        # Injected newline-separated string of requirements (each line: name:version)
        REQUIRED_RAW_DATA="{{ required_packages_raw_data }}"
        
        REPORT_DATA=""
        HOST_NAME="{{ inventory_hostname }}"
        
        # Read the raw data line by line
        while IFS= read -r RAW_ENTRY; do
            if [[ -z "$RAW_ENTRY" ]]; then continue; fi

            # --- 1. Robust Split using Bash Regex (name:version format) ---
            # Find the package name and the minimum required EVR
            # e.g., 'bash:4.4.18-15.el8' -> PKG_NAME_LOOKUP='bash', REQUIRED_EVR='4.4.18-15.el8'
            
            # Regex to capture name before : and version after :
            regex='^([^:]+):(.*)$'
            
            if [[ "$RAW_ENTRY" =~ $regex ]]; then
                PKG_NAME_LOOKUP="${BASH_REMATCH[1]}" # e.g., 'bash-completion'
                REQUIRED_EVR="${BASH_REMATCH[2]}"    # e.g., '2.7.1-5.el8'
            else
                continue # Failed to parse
            fi
            
            # Sanity check
            if [[ -z "$PKG_NAME_LOOKUP" ]] || [[ -z "$REQUIRED_EVR" ]]; then
                continue
            fi
            
            # --- 2. Query Installed Versions ---
            # Get only Version-Release (V-R) for comparison, one per line.
            # Using V-R is simpler for sort -V if we don't need Epoch.
            INSTALLED_EVRS=$(rpm -qa "$PKG_NAME_LOOKUP" --queryformat '%{VERSION}-%{RELEASE}\n' 2>/dev/null)
            
            if [[ -z "$INSTALLED_EVRS" ]]; then
                continue # Package not installed
            fi

            # --- 3. Comparison Logic ---
            
            ALL_INSTALLED_COMPLIANT=1
            OLDEST_DEFICIENT_EVR="" # Tracks the lowest installed V-R that is deficient

            # Read installed versions line by line
            while IFS= read -r installed_vr; do
                if [[ -z "$installed_vr" ]]; then continue; fi
                
                # Comparison: Check if the installed version is STRICTLY older than the required version.
                # If installed_vr < REQUIRED_EVR, it means installed version is deficient.
                
                # Check 1: Use sort -V to find the lowest version between installed and required.
                # If the lowest version is the installed one, and they are not identical, it's deficient.
                
                # Feed both versions, separated by newline, into sort -V and grab the first (lowest) line.
                LOWEST_VERSION=$(echo -e "$installed_vr\n$REQUIRED_EVR" | sort -V | head -n 1)

                if [[ "$LOWEST_VERSION" == "$installed_vr" ]] && [[ "$installed_vr" != "$REQUIRED_EVR" ]]; then
                    # The installed version is deficient (strictly older)
                    ALL_INSTALLED_COMPLIANT=0
                    
                    # Track the oldest deficient package found so far
                    if [[ -z "$OLDEST_DEFICIENT_EVR" ]]; then
                       OLDEST_DEFICIENT_EVR="$installed_vr"
                    else
                        # Compare: Is the current deficient installed_vr older than the tracked one?
                        OLDEST_CHECK=$(echo -e "$installed_vr\n$OLDEST_DEFICIENT_EVR" | sort -V | head -n 1)
                        if [[ "$OLDEST_CHECK" == "$installed_vr" ]]; then
                            # Yes, the current one is older (more deficient)
                            OLDEST_DEFICIENT_EVR="$installed_vr"
                        fi
                    fi
                fi
            done <<< "$INSTALLED_EVRS"
            
            # --- 4. Final Reporting ---
            # If any installed package for this base name failed the requirement:
            if [[ "$ALL_INSTALLED_COMPLIANT" -eq 0 ]] && [[ -n "$OLDEST_DEFICIENT_EVR" ]]; then
                # Report the oldest deficient installed version against the required minimum.
                REPORT_DATA+="$HOST_NAME|$PKG_NAME_LOOKUP|$OLDEST_DEFICIENT_EVR|$REQUIRED_EVR\n"
            fi
            
        done <<< "$REQUIRED_RAW_DATA" # Feed the main requirement list into the loop
        
        echo -e "$REPORT_DATA"
      register: package_check_results
      changed_when: false

    - name: Generate and write a single combined report
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        content: |
          # Package Version Deficiencies Report
          # Generated by Ansible at: {{ ansible_date_time.iso8601 | regex_replace('\\..*$', '') }}
          # -------------------------------------------------------------
          # HOSTNAME,PACKAGE_NAME,INSTALLED_VERSION,REQUIRED_MINIMUM_VERSION

          {% for host in ansible_play_hosts %}
          {% set raw_stdout = hostvars[host].package_check_results.stdout | default('') %}
          {% set raw_lines = raw_stdout.split('\n') | map('trim') | reject('equalto', '') | list %}
          
          {% for line in raw_lines %}
          {% set parts = line.split('|') %}
          {% if parts | length == 4 %}
          {{ parts[0] | upper }},{{ parts[1] }},{{ parts[2] }},{{ parts[3] }}
          {% endif %}
          {% endfor %}
          {% endfor %}
        dest: "{{ output_file }}"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ primary_group.stdout | default(omit) }}"
        mode: '0644'