- name: Check RHEL package versions
  ignore_unreachable: yes
  hosts: reachable
  become: true
  vars_files:
    - ../../vaults/vbox_vault.yml
  vars:
    ansible_become_password: "{{ remote_host_become_pass }}"
    ansible_remote_tmp: /var/ansible_tmp
    # Pass the raw lines directly to the shell script
    required_packages_raw: "{{ lookup('file', playbook_dir + '/../../files/package_versions.txt').splitlines() | map('trim') | reject('equalto', '') | list }}"
    output_file: "{{ playbook_dir }}/../../files/rhel_vulnerability_report.txt"

  tasks:
    - name: Get primary group for local file permissions
      delegate_to: localhost
      ansible.builtin.command: id -gn {{ lookup('env', 'USER') }}
      register: primary_group
      changed_when: false
    - name: Execute single-pass, optimized version check
      ansible.builtin.shell: |
        #!/bin/bash
        
        # --- Package Data Template (Injected by Ansible) ---
        # Inject the raw required packages list as a structured array
        REQUIRED_RAW=(
        {% for line in required_packages_raw %}
          "{{ line }}"
        {% endfor %}
        )
        # ----------------------------------------------------
        
        REPORT_DATA=""
        HOST_NAME="{{ inventory_hostname }}"
        
        # Iterate over the injected array
        for RAW_ENTRY in "${REQUIRED_RAW[@]}"; do
            if [[ -z "$RAW_ENTRY" ]]; then continue; fi

            # --- 1. Reliable Split using SED ---
            # PKG_PREFIX\nREQUIRED_EVR
            
            # Using parameter expansion to capture sed output is cleaner than pipes
            SPLIT_DATA=$(echo "$RAW_ENTRY" | sed -r 's/^(.*)-([0-9].*)$/\1\n\2/')
            
            # Check if sed successfully generated two lines
            if [[ $(echo "$SPLIT_DATA" | wc -l) -ne 2 ]]; then
                # Unable to parse this line, skip
                continue
            fi
            
            # Use printf for reliable extraction without newline issues
            readarray -t SPLIT_ARRAY < <(printf "%s" "$SPLIT_DATA")
            
            PKG_NAME_PREFIX="${SPLIT_ARRAY[0]}"
            REQUIRED_EVR="${SPLIT_ARRAY[1]}"

            # --- 2. Determine Base Package Name ---
            # Heuristic for Kernel/versioned packages: 'kernel-4.18.0' -> 'kernel'
            PKG_NAME_BASE="$PKG_NAME_PREFIX"
            if [[ "$PKG_NAME_PREFIX" =~ -[0-9] ]]; then
                PKG_NAME_BASE="${PKG_NAME_PREFIX%%-*}"
            fi
            
            # --- 3. Query Installed Versions ---
            
            # Use rpm -q to check if the base package exists AND get installed versions
            INSTALLED_EVRS=$(rpm -qa "$PKG_NAME_BASE" --queryformat '%{VERSION}-%{RELEASE}\n' 2>/dev/null)
            
            # Requirement #2: If not installed, skip the report entirely.
            if [[ -z "$INSTALLED_EVRS" ]]; then
                continue
            fi

            # --- 4. Comparison Logic ---
            
            MEETS_REQUIREMENT=0
            OLDEST_DEFICIENT_EVR=""

            # Read installed versions line by line
            while IFS= read -r installed_evr; do
                if [[ -z "$installed_evr" ]]; then continue; fi
                
                # Comparison string: installed_evr\nrequired_evr
                # If installed_evr is the first version alphabetically/numerically, it is deficient or equal.
                FIRST_VERSION=$(echo -e "$installed_evr\n$REQUIRED_EVR" | sort -V | head -n 1)

                if [[ "$FIRST_VERSION" == "$installed_evr" ]] && [[ "$installed_evr" != "$REQUIRED_EVR" ]]; then
                    # Installed version is deficient. Track the oldest deficient one.
                    
                    if [[ -z "$OLDEST_DEFICIENT_EVR" ]]; then
                       OLDEST_DEFICIENT_EVR="$installed_evr"
                    else
                        # Compare stored oldest vs current installed
                        LOWEST_CHECK=$(echo -e "$installed_evr\n$OLDEST_DEFICIENT_EVR" | sort -V | head -n 1)
                        if [[ "$LOWEST_CHECK" == "$installed_evr" ]]; then
                            # New installed version is even older than the previously tracked one
                            OLDEST_DEFICIENT_EVR="$installed_evr"
                        fi
                    fi
                else
                    # Installed version meets or exceeds requirement (This handles Requirement #3 implicitly)
                    MEETS_REQUIREMENT=1
                    break # Optimization: job done for this package
                fi
            done <<< "$INSTALLED_EVRS"
            
            # --- 5. Final Reporting (Only report deficiencies) ---
            
            if [[ "$MEETS_REQUIREMENT" -eq 0 ]] && [[ -n "$OLDEST_DEFICIENT_EVR" ]]; then
                # Report when all installed versions are deficient.
                REPORT_DATA+="$HOST_NAME|$PKG_NAME_BASE|$OLDEST_DEFICIENT_EVR|$REQUIRED_EVR\n"
            fi
            
        done # End of RAW_ENTRY loop
        
        echo -e "$REPORT_DATA"
      register: package_check_results
      changed_when: false

    - name: Generate and write a single combined report
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        content: |
          # Package Version Deficiencies Report
          # Generated at: {{ ansible_date_time.iso8601 | regex_replace('\\..*$', '') }}
          # -------------------------------------------------------------
          # HOSTNAME,PACKAGE_NAME,INSTALLED_VERSION,REQUIRED_MINIMUM_VERSION

          {% for host in ansible_play_hosts %}
          {% set raw_stdout = hostvars[host].package_check_results.stdout | default('') %}
          {% set raw_lines = raw_stdout.split('\n') | map('trim') | reject('equalto', '') | list %}
          
          {% for line in raw_lines %}
          {% set parts = line.split('|') %}
          {% if parts | length == 4 %}
          {{ parts[0] | upper }},{{ parts[1] }},{{ parts[2] }},{{ parts[3] }}
          {% endif %}
          {% endfor %}
          {% endfor %}
        dest: "{{ output_file }}"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ primary_group.stdout }}"
        mode: '0644'