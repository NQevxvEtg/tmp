- name: Check RHEL package versions
  ignore_unreachable: yes
  hosts: reachable
  become: true
  vars_files:
    - ../../vaults/vbox_vault.yml
  vars:
    ansible_become_password: "{{ remote_host_become_pass }}"
    ansible_remote_tmp: /var/ansible_tmp
    # Pass the raw lines directly to the shell script
    required_packages_raw: "{{ lookup('file', playbook_dir + '/../../files/package_versions.txt').splitlines() | map('trim') | reject('equalto', '') | list }}"
    output_file: "{{ playbook_dir }}/../../files/rhel_vulnerability_report.txt"

  tasks:
    - name: Get primary group for local file permissions
      delegate_to: localhost
      ansible.builtin.command: id -gn {{ lookup('env', 'USER') }}
      register: primary_group
      changed_when: false

    - name: Execute Bash script fragment on remote host to check versions
      # Use `|` (pipe) to preserve newlines and avoid quoting issues with single quotes
      ansible.builtin.shell: |
        #!/bin/bash
        
        # --- Package Data Template (Injected by Ansible) ---
        # Inject the raw list of required packages (e.g., kernel-4.18.0-555.69.1.el8_10)
        REQUIRED_RAW=(
        {% for line in required_packages_raw %}
          "{{ line }}"
        {% endfor %}
        )
        # REQUIRED_VERSIONS map will store: [base_pkg_name]=required_version
        declare -A REQUIRED_VERSIONS
        # ----------------------------------------------------

        REPORT_DATA=""
        HOST_NAME="{{ inventory_hostname }}"

        # Function to split raw entry into base package name and minimum required version
        parse_required_packages() {
            local raw_entry="$1"
            
            # 1. Find the split point (the last hyphen before a digit that starts the version)
            # Use grep/awk/sed to separate NAME-VERSION. This is more reliable than pure Bash for complex strings.
            # Example: kernel-4.18.0-555.69.1.el8_10
            
            if [[ "$raw_entry" =~ ^(.*?)-([0-9].*)$ ]]; then
                # BASH_REMATCH[1] is the name prefix (e.g., kernel-4.18.0)
                # BASH_REMATCH[2] is the required version (e.g., 555.69.1.el8_10)
                local pkg_name_prefix="${BASH_REMATCH[1]}"
                local required_ver="${BASH_REMATCH[2]}"
                
                # 2. Clean the prefix down to the base package name (e.g., kernel-4.18.0 -> kernel)
                local pkg_name_base
                # Check if the prefix still contains a version (i.e. if it contains a hyphen followed by a digit)
                if [[ "$pkg_name_prefix" =~ -[0-9] ]]; then
                    # Extract the part before the first hyphen
                    pkg_name_base="${pkg_name_prefix%%-*}"
                else
                    pkg_name_base="$pkg_name_prefix"
                fi

                # Store result in the global map
                REQUIRED_VERSIONS["$pkg_name_base"]="$required_ver"
            fi
        }

        # First pass: Populate REQUIRED_VERSIONS map
        for entry in "${REQUIRED_RAW[@]}"; do
            if [[ -n "$entry" ]]; then
               parse_required_packages "$entry"
            fi
        done
        
        # Function to process an installed base package and all its versions
        process_package() {
            local pkg_name="$1"
            local required_ver="${REQUIRED_VERSIONS[$pkg_name]}"

            # Use rpm -qa to list ALL installed packages matching the base name
            INSTALLED_VERSIONS=$(rpm -qa "$pkg_name" --qf '%{VERSION}-%{RELEASE}\n' 2>/dev/null)
            
            if [[ -z "$INSTALLED_VERSIONS" ]]; then
                REPORT_DATA+="$HOST_NAME|$pkg_name|NOT_INSTALLED|$required_ver\n"
                return
            fi

            MEETS_REQUIREMENT=0
            LOWEST_DEFICIENT_INSTALLED_VER=""

            # Iterate through all installed versions
            while IFS= read -r installed_ver; do
                if [[ -z "$installed_ver" ]]; then continue; fi

                # Version Comparison (requires sort -V)
                FIRST_VERSION=$(echo -e "$installed_ver\n$required_ver" | sort -V | head -n 1)

                if [[ "$FIRST_VERSION" == "$installed_ver" ]] && [[ "$installed_ver" != "$required_ver" ]]; then
                    # This installed version is deficient. Track the lowest one.
                    if [[ -z "$LOWEST_DEFICIENT_INSTALLED_VER" ]]; then
                       LOWEST_DEFICIENT_INSTALLED_VER="$installed_ver"
                    else
                        LOWEST_CHECK=$(echo -e "$installed_ver\n$LOWEST_DEFICIENT_INSTALLED_VER" | sort -V | head -n 1)
                        if [[ "$LOWEST_CHECK" == "$installed_ver" ]]; then
                            LOWEST_DEFICIENT_INSTALLED_VER="$installed_ver"
                        fi
                    fi
                else
                    # Found at least one package that meets the requirement
                    MEETS_REQUIREMENT=1
                fi
            done <<< "$INSTALLED_VERSIONS"
            
            # Report failure only if no installed version met the required minimum
            if [[ "$MEETS_REQUIREMENT" -eq 0 ]] && [[ -n "$LOWEST_DEFICIENT_INSTALLED_VER" ]]; then
                REPORT_DATA+="$HOST_NAME|$pkg_name|$LOWEST_DEFICIENT_INSTALLED_VER|$required_ver\n"
            fi
        }

        # Second pass: Process packages using the populated map
        for pkg_name in "${!REQUIRED_VERSIONS[@]}"; do
            process_package "$pkg_name"
        done

        echo -e "$REPORT_DATA"
      register: package_check_results
      changed_when: false

    - name: Generate and write a single combined report
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        content: |
          # Package Version Deficiencies Report
          # Generated at: {{ ansible_date_time.iso8601 | regex_replace('\\..*$', '') }}
          # -------------------------------------------------------------
          # HOSTNAME,PACKAGE_NAME,INSTALLED_VERSION,REQUIRED_MINIMUM_VERSION

          {% for host in ansible_play_hosts %}
          {% set raw_stdout = hostvars[host].package_check_results.stdout | default('') %}
          {% set raw_lines = raw_stdout.split('\n') | map('trim') | reject('equalto', '') | list %}
          
          {% for line in raw_lines %}
          {% set parts = line.split('|') %}
          {% if parts | length == 4 %}
          {{ parts[0] | upper }},{{ parts[1] }},{{ parts[2] }},{{ parts[3] }}
          {% endif %}
          {% endfor %}
          {% endfor %}
        dest: "{{ output_file }}"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ primary_group.stdout }}"
        mode: '0644'