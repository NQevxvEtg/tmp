- name: Check RHEL package versions
  ignore_unreachable: yes
  hosts: reachable
  become: true
  vars_files: 
    - ../../vaults/vbox_vault.yml  
  vars:
    ansible_become_password: "{{ remote_host_become_pass }}"
    ansible_remote_tmp: /var/ansible_tmp
    required_packages_raw: "{{ lookup('file', playbook_dir + '/../../files/package_versions.txt').splitlines() }}"
    output_file: "{{ playbook_dir }}/../../files/rhel_vulnerability_report.txt"

  tasks:
    - name: Get primary group for local file permissions
      delegate_to: localhost
      ansible.builtin.command: id -gn {{ lookup('env', 'USER') }}
      register: primary_group
      changed_when: false

    - name: Execute Bash script fragment on remote host to check versions
      # Use `|` (pipe) to preserve newlines and avoid quoting issues with single quotes
      ansible.builtin.shell: |
        #!/bin/bash
        
        # --- Package Data Template (Injected by Ansible) ---
        declare -A REQUIRED_VERSIONS
        {% for line in required_packages_raw %}
        {% set parts = line | regex_replace('^(.*)-([0-9].*)$', '\1,\2') | split(',') %}
        REQUIRED_VERSIONS["{{ parts[0] }}"]="{{ parts[1] }}"
        {% endfor %}
        # ----------------------------------------------------

        REPORT_DATA=""
        HOST_NAME="{{ inventory_hostname }}"
        
        # Function to process an installed line (Name-Epoch:Version-Release.Arch)
        process_package() {
            local pkg_name="$1"
            local required_ver="${REQUIRED_VERSIONS[$pkg_name]}"

            # 1. Check if the package is installed
            # Check for silent failure (2>/dev/null)
            if ! INSTALLED_INFO=$(rpm -q "$pkg_name" 2>/dev/null); then
                # Package not installed: Output: HOST|PACKAGE|INSTALLED_VERSION|REQUIRED_VERSION
                REPORT_DATA+="$HOST_NAME|$pkg_name|NOT_INSTALLED|$required_ver\n"
                return
            fi
            
            # 2. Extract the installed version-release part for comparison
            # rpm output looks like: pkg-version-release.arch
            local installed_ver=$(echo "$INSTALLED_INFO" | sed -E "s/^$pkg_name-(.*)\..*$/\1/")
            
            # --- Robust Version Comparison using sort -V ---
            
            # Get the version that is numerically lowest
            FIRST_VERSION=$(echo -e "$installed_ver\n$required_ver" | sort -V | head -n 1)

            # Check if the installed version is numerically lower than the required version (and they are not equal)
            if [[ "$FIRST_VERSION" == "$installed_ver" ]] && [[ "$installed_ver" != "$required_ver" ]]; then
                # DEFICIENT: Output: HOST|PACKAGE|INSTALLED_VERSION|REQUIRED_VERSION
                REPORT_DATA+="$HOST_NAME|$pkg_name|$installed_ver|$required_ver\n"
            fi
        }

        # Main loop to process all required packages
        for pkg_name in "${!REQUIRED_VERSIONS[@]}"; do
            process_package "$pkg_name"
        done

        # Output the collected pipe-delimited lines
        echo -e "$REPORT_DATA"
      register: package_check_results
      changed_when: false

    - name: Generate and write a single combined report
      delegate_to: localhost
      run_once: true
      ansible.builtin.copy:
        content: |
          # Package Version Deficiencies Report
          # Generated at: {{ ansible_date_time.iso8601 | regex_replace('\\..*$', '') }}
          # -------------------------------------------------------------
          # HOSTNAME,PACKAGE_NAME,INSTALLED_VERSION,REQUIRED_MINIMUM_VERSION

          {% for host in ansible_play_hosts %}
          {# Use stdout and split by newline for robustness #}
          {% set raw_stdout = hostvars[host].package_check_results.stdout | default('') %}
          {% set raw_lines = raw_stdout.split('\n') | map('trim') | reject('equalto', '') | list %}
          
          {% for line in raw_lines %}
          {# Split the pipe-delimited string: HOST|PACKAGE|... #}
          {% set parts = line.split('|') %}
          {% if parts | length == 4 %}
          {{ parts[0] | upper }},{{ parts[1] }},{{ parts[2] }},{{ parts[3] }}
          {% endif %}
          {% endfor %}
          {% endfor %}
        dest: "{{ output_file }}"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ primary_group.stdout }}"
        mode: '0644'